/**
 * IWLS Internal REST API
 * This rest api has been design for the internal uses of the waterlevel system. All the GET request are to receive data that are in the database. All the POST request are to add prediction to the database.
 *
 * The version of the OpenAPI document: 1.0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { ImageDTO } from '../model/models';
import { ImageMetadata } from '../model/models';
import { ImageVersion } from '../model/models';
import { InlineObject } from '../model/models';
import { InlineObject1 } from '../model/models';
import { PageDTOImageDTO } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class ImagesService {

    protected basePath = 'https://intra-api.test.iwls.azure.cloud.dfo-mpo.gc.ca';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Delete an image and all its versions
     * @param id Id of the image to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteImage(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<string>;
    public deleteImage(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<string>>;
    public deleteImage(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<string>>;
    public deleteImage(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteImage.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.delete<string>(`${this.configuration.basePath}/rest/images/${encodeURIComponent(String(id))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an version of an existing image
     * @param id Id of the image
     * @param version Id of the version to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteImageVersion(id: string, version: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<string>;
    public deleteImageVersion(id: string, version: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<string>>;
    public deleteImageVersion(id: string, version: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<string>>;
    public deleteImageVersion(id: string, version: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteImageVersion.');
        }
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteImageVersion.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.delete<string>(`${this.configuration.basePath}/rest/images/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(version))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get an image from its id
     * @param id Id of the image to get
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getImage(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<ImageDTO>;
    public getImage(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<ImageDTO>>;
    public getImage(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<ImageDTO>>;
    public getImage(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getImage.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<ImageDTO>(`${this.configuration.basePath}/rest/images/${encodeURIComponent(String(id))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get an image metadata from its id
     * @param id Id of the image
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getImageMetadata(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<ImageMetadata>;
    public getImageMetadata(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<ImageMetadata>>;
    public getImageMetadata(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<ImageMetadata>>;
    public getImageMetadata(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getImageMetadata.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<ImageMetadata>(`${this.configuration.basePath}/rest/images/${encodeURIComponent(String(id))}/metadata`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a version from an image
     * @param id Id of the image
     * @param versionId Id of the version to get
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getImageVersion(id: string, versionId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<ImageVersion>;
    public getImageVersion(id: string, versionId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<ImageVersion>>;
    public getImageVersion(id: string, versionId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<ImageVersion>>;
    public getImageVersion(id: string, versionId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getImageVersion.');
        }
        if (versionId === null || versionId === undefined) {
            throw new Error('Required parameter versionId was null or undefined when calling getImageVersion.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<ImageVersion>(`${this.configuration.basePath}/rest/images/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(versionId))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all versions of an image
     * @param id Id of the image you want to list version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listVersion(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<Array<ImageVersion>>;
    public listVersion(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<Array<ImageVersion>>>;
    public listVersion(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<Array<ImageVersion>>>;
    public listVersion(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listVersion.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<Array<ImageVersion>>(`${this.configuration.basePath}/rest/images/${encodeURIComponent(String(id))}/versions`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get images sorted in a paginated format, you can search using various filter
     * You can filter results using only one of the following parameters at a time: stations (station-ids) and benchmarks (benchmark-ids), bounding box (bbox) and point (point and radius) but only one filter at the same time
     * @param page Number of the page, has to be 0 at minimum
     * @param pageLength Number of items per page, between 1 and 400
     * @param bbox Bounding box for which you want to search, the bounding box must be and array of value in this order: minLat,minLong,maxLat,maxLong. You cannot search for stationIds and benchmarkIds or point at the same time.
     * @param point Point for which you want to search, the point must be and array of value in this order: lat,long. Must be set with radius. You cannot search for stationIds and benchmarkIds or bbox at the same time.
     * @param radius Radius in kilometer around the point to search, the radius must be set with point. You cannot search for stationIds and benchmarkIds or bbox at the same time.
     * @param stationIds Array of station IDs you want to search. You cannot search for bbox or point at the same time.
     * @param benchmarkIds Array of benchmark IDs you want to search. You cannot search for bbox or point at the same time.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchImages(page?: number, pageLength?: number, bbox?: Array<number>, point?: Array<number>, radius?: number, stationIds?: Array<string>, benchmarkIds?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<PageDTOImageDTO>;
    public searchImages(page?: number, pageLength?: number, bbox?: Array<number>, point?: Array<number>, radius?: number, stationIds?: Array<string>, benchmarkIds?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<PageDTOImageDTO>>;
    public searchImages(page?: number, pageLength?: number, bbox?: Array<number>, point?: Array<number>, radius?: number, stationIds?: Array<string>, benchmarkIds?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<PageDTOImageDTO>>;
    public searchImages(page?: number, pageLength?: number, bbox?: Array<number>, point?: Array<number>, radius?: number, stationIds?: Array<string>, benchmarkIds?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>page, 'page');
        }
        if (pageLength !== undefined && pageLength !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>pageLength, 'page-length');
        }
        if (bbox) {
            bbox.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'bbox');
            })
        }
        if (point) {
            point.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'point');
            })
        }
        if (radius !== undefined && radius !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>radius, 'radius');
        }
        if (stationIds) {
            stationIds.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'station-ids');
            })
        }
        if (benchmarkIds) {
            benchmarkIds.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'benchmark-ids');
            })
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<PageDTOImageDTO>(`${this.configuration.basePath}/rest/images`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update an image\&#39;s metadata
     * @param id
     * @param date Date the image was taken, in ISO 8601 format UTC  (e.g. : 2020-06-30T19:15:09Z
     * @param status Status of the image Only 2 values accepted (\&quot;active\&quot; or \&quot;historic\&quot;)
     * @param latitude Latitude of the picture, betweeen -90 and 90
     * @param longitude Longitude of the picture, between -180 and 180
     * @param gpsDirection Orientation in degrees, between 0 and 359
     * @param tags List of tags (keywords) that describe the image (ie. : aerial, shed, sensor)
     * @param stationId Id of the related Station
     * @param benchmarkId Id of the related Benchmark
     * @param type Type of the image  Only 2 values accepted (\&quot;picture\&quot; or \&quot;sketch\&quot;)
     * @param author Name of the photograph or editor of the image
     * @param copyright Copyright applicable to the image  \&quot;CHS-SHC\&quot; by default
     * @param comment Plain text to add additional information concerning the image
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateMetadata(id: string, date: string, status: string, latitude?: number, longitude?: number, gpsDirection?: number, tags?: Array<string>, stationId?: string, benchmarkId?: string, type?: string, author?: string, copyright?: string, comment?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<ImageMetadata>;
    public updateMetadata(id: string, date: string, status: string, latitude?: number, longitude?: number, gpsDirection?: number, tags?: Array<string>, stationId?: string, benchmarkId?: string, type?: string, author?: string, copyright?: string, comment?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<ImageMetadata>>;
    public updateMetadata(id: string, date: string, status: string, latitude?: number, longitude?: number, gpsDirection?: number, tags?: Array<string>, stationId?: string, benchmarkId?: string, type?: string, author?: string, copyright?: string, comment?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<ImageMetadata>>;
    public updateMetadata(id: string, date: string, status: string, latitude?: number, longitude?: number, gpsDirection?: number, tags?: Array<string>, stationId?: string, benchmarkId?: string, type?: string, author?: string, copyright?: string, comment?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMetadata.');
        }
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling updateMetadata.');
        }
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling updateMetadata.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (date !== undefined && date !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>date, 'date');
        }
        if (latitude !== undefined && latitude !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>latitude, 'latitude');
        }
        if (longitude !== undefined && longitude !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>longitude, 'longitude');
        }
        if (gpsDirection !== undefined && gpsDirection !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>gpsDirection, 'gpsDirection');
        }
        if (tags) {
            tags.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'tags');
            })
        }
        if (stationId !== undefined && stationId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>stationId, 'stationId');
        }
        if (benchmarkId !== undefined && benchmarkId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>benchmarkId, 'benchmarkId');
        }
        if (type !== undefined && type !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>type, 'type');
        }
        if (status !== undefined && status !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>status, 'status');
        }
        if (author !== undefined && author !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>author, 'author');
        }
        if (copyright !== undefined && copyright !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>copyright, 'copyright');
        }
        if (comment !== undefined && comment !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>comment, 'comment');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<ImageMetadata>(`${this.configuration.basePath}/rest/images/${encodeURIComponent(String(id))}/metadata`,
            null,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Upload an image as Multipart with it\&#39;s complete metadata
     * @param date Date the image was taken, in ISO 8601 format UTC  (e.g. : 2020-06-30T19:15:09Z)
     * @param status Status of the image Only 2 values accepted (\&quot;active\&quot; or \&quot;historic\&quot;)
     * @param uploader Name of the person who uploads the file
     * @param latitude Latitude of the picture, betweeen -90 and 90
     * @param longitude Longitude of the picture, between -180 and 180
     * @param gpsDirection Orientation in degrees, between 0 and 359
     * @param tags List of tags (keywords) that describe the image (ie. : aerial, shed, sensor)
     * @param stationId Id of the related Station, cannot be set with benchmarkId
     * @param benchmarkId Id of the related Benchmark, cannot be set with stationId
     * @param type Type of the image  Only 2 values accepted (\&quot;picture\&quot; or \&quot;sketch\&quot;)
     * @param author Name of the photograph or editor of the image
     * @param copyright Copyright applicable to the image  \&quot;CHS-SHC\&quot; by default
     * @param comment Plain text to add additional information concerning the image
     * @param inlineObject
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uploadImage(date: string, status: string, uploader: string, latitude?: number, longitude?: number, gpsDirection?: number, tags?: Array<string>, stationId?: string, benchmarkId?: string, type?: string, author?: string, copyright?: string, comment?: string, inlineObject?: InlineObject, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<ImageMetadata>;
    public uploadImage(date: string, status: string, uploader: string, latitude?: number, longitude?: number, gpsDirection?: number, tags?: Array<string>, stationId?: string, benchmarkId?: string, type?: string, author?: string, copyright?: string, comment?: string, inlineObject?: InlineObject, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<ImageMetadata>>;
    public uploadImage(date: string, status: string, uploader: string, latitude?: number, longitude?: number, gpsDirection?: number, tags?: Array<string>, stationId?: string, benchmarkId?: string, type?: string, author?: string, copyright?: string, comment?: string, inlineObject?: InlineObject, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<ImageMetadata>>;
    public uploadImage(date: string, status: string, uploader: string, latitude?: number, longitude?: number, gpsDirection?: number, tags?: Array<string>, stationId?: string, benchmarkId?: string, type?: string, author?: string, copyright?: string, comment?: string, inlineObject?: InlineObject, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling uploadImage.');
        }
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling uploadImage.');
        }
        if (uploader === null || uploader === undefined) {
            throw new Error('Required parameter uploader was null or undefined when calling uploadImage.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (date !== undefined && date !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>date, 'date');
        }
        if (latitude !== undefined && latitude !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>latitude, 'latitude');
        }
        if (longitude !== undefined && longitude !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>longitude, 'longitude');
        }
        if (gpsDirection !== undefined && gpsDirection !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>gpsDirection, 'gpsDirection');
        }
        if (tags) {
            tags.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'tags');
            })
        }
        if (stationId !== undefined && stationId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>stationId, 'stationId');
        }
        if (benchmarkId !== undefined && benchmarkId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>benchmarkId, 'benchmarkId');
        }
        if (type !== undefined && type !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>type, 'type');
        }
        if (status !== undefined && status !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>status, 'status');
        }
        if (author !== undefined && author !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>author, 'author');
        }
        if (copyright !== undefined && copyright !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>copyright, 'copyright');
        }
        if (comment !== undefined && comment !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>comment, 'comment');
        }
        if (uploader !== undefined && uploader !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>uploader, 'uploader');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.post<ImageMetadata>(`${this.configuration.basePath}/rest/images/upload`,
            inlineObject,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Upload an image as Multipart to update an existing image
     * @param uploader Name of the person who uploads the file
     * @param id
     * @param inlineObject1
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uploadVersion(uploader: string, id: string, inlineObject1?: InlineObject1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<ImageVersion>;
    public uploadVersion(uploader: string, id: string, inlineObject1?: InlineObject1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<ImageVersion>>;
    public uploadVersion(uploader: string, id: string, inlineObject1?: InlineObject1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<ImageVersion>>;
    public uploadVersion(uploader: string, id: string, inlineObject1?: InlineObject1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {
        if (uploader === null || uploader === undefined) {
            throw new Error('Required parameter uploader was null or undefined when calling uploadVersion.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling uploadVersion.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (uploader !== undefined && uploader !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>uploader, 'uploader');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.post<ImageVersion>(`${this.configuration.basePath}/rest/images/${encodeURIComponent(String(id))}/versions/upload`,
            inlineObject1,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
